[[_git_commands]]
[appendix]
== Mga Kautusan ng Git

Sa buong aklat ipinakilala namin ang dosedosenang mga kautusan ng Git at sinubukang ipakilala ang mga ito sa loob ng isang salaysay, dahan-dahang magdagdag ng maraming mga kautusan sa kuwento.
Gayunpaman, ito ay nagbigay sa amin ng mga halimbawa sa paggamit ng mga kautusan na watak-watak medyo sa buong aklat.

Sa apendiks na ito, tayo ay dadaan sa lahat ng mga kautusan ng Git binanggit natin sa buong aklat, halos pinagsama aling gamitin sa.

Pag-uusapan natin ang bawat kautosan kung ano sa pangkalahatan ang ginagawa at pagkatapos ay ipakita kung saan sa aklat mahanap natin pagkakaroon gamitin ito.

=== Setup at Config 

Mayroong dalawang mga kautosan na madalas ginagamit, mula sa unang mga tawag ng Git sa karaniwang araw-araw na pag-aayos at sanggunian, ang `config` at `help` na mga kautusan.

==== git config

Ang Git ay may default na paraan sa paggawa ng daan-daanug mga bagay.
Git has a default way of doing hundreds of things.
Para sa maraming mga bagay na ito, maaari mong sabihin sa Git sa default na gawin ang mga ito ng ibang paraan, o itakda ang iyong mga kagustuhan.
Ito ay nagsasangkot ng lahat mula sa pagsasabi sa Git kung ano ang iyong pangalan sa mga partikular na kagustuhan sa kulay ng terminal o kung anong editor ang iyong ginagamit.
Mayroong ilang mga file ang utos na ito ay babasahin at isulat sa gayon maaari mong itakda ang mga halaga globally o down sa mga tiyak na mga repository.

Git has a default way of doing hundreds of things.
For a lot of these things, you can tell Git to default to doing them a different way, or set your preferences.
This involves everything from telling Git what your name is to specific terminal color preferences or what editor you use.
There are several files this command will read from and write to so you can set values globally or down to specific repositories.

Ang kautusang `git config` ay ginamit sa halos bawat kabanata ng aklat.
The `git config` command has been used in nearly every chapter of the book.

Sa << _ getting_started # _first_time >> ginamit namin ito upang tukuyin ang aming pangalan, email address at kagustuhan sa editor bago pa namin makapagsimula gamit ang Git.
In <<_getting_started#_first_time>> we used it to specify our name, email address and editor preference before we even got started using Git.

Sa << _ git_basics_chapter # _git_aliases >> ipinakita namin kung paano mo magagamit ito upang lumikha ng mga command na shorthand na lumalawak sa mahabang mga pagkakasunud-sunod ng pagpipilian upang hindi mo kailangang i-type ang mga ito sa bawat oras.
In <<_git_basics_chapter#_git_aliases>> we showed how you could use it to create shorthand commands that expand to long option sequences so you don't have to type them every time.

Sa << _ git_branching # _rebasing >> ginamit namin ito upang gumawa ng --rebase ang default kapag nagpatakbo ka ng` git pull`.
In <<_git_branching#_rebasing>> we used it to make `--rebase` the default when you run `git pull`.

Sa << _ git_tools # _credential_caching >> ginamit namin ito upang mag-set up ng isang default na tindahan para sa iyong mga HTTP password.
In <<_git_tools#_credential_caching>> we used it to set up a default store for your HTTP passwords.

Sa << _ customizing_git # _keyword_expansion >> ipinakita namin kung paano i-set up ang smudge at malinis na mga filter sa nilalaman na dumarating sa at sa labas ng Git.
In <<_customizing_git#_keyword_expansion>> we showed how to set up smudge and clean filters on content coming in and out of Git.

Sa wakas, karaniwang ang kabuuan ng << _ git_config >> ay nakatuon sa utos.
Finally, basically the entirety of <<_git_config>> is dedicated to the command.

==== git help
Ang command na `git help` ay ginagamit upang ipakita sa iyo ang lahat ng dokumentasyon na naipadala sa Git tungkol sa anumang command.
Habang nagbibigay kami ng isang magaspang na pangkalahatang-ideya ng karamihan sa mga mas sikat sa apendiks na ito, para sa isang buong listahan ng lahat ng mga posibleng pagpipilian at mga flag para sa bawat command, maaari mong palaging magpatakbo ng git tulong <command>.

The `git help` command is used to show you all the documentation shipped with Git about any command.
While we're giving a rough overview of most of the more popular ones in this appendix, for a full listing of all of the possible options and flags for every command, you can always run `git help <command>`.

Ipinakilala namin ang git help command sa << _ git_help >> at ipinakita sa iyo kung paano gamitin ito upang makahanap ng karagdagang impormasyon tungkol sa` git shell` sa << _ git_on_the_server # _setting_up_server >>.
We introduced the `git help` command in <<_git_help>> and showed you how to use it to find more information about the `git shell` in <<_git_on_the_server#_setting_up_server>>.


=== Getting and Creating Projects

Mayroong dalawang mga paraan upang makakuha ng Git repository.
Ang isa ay upang kopyahin ito mula sa isang umiiral na repository sa network o sa ibang lugar at ang iba pang ay upang lumikha ng isang bago sa isang umiiral na direktoryo.

There are two ways to get a Git repository.
One is to copy it from an existing repository on the network or elsewhere and the other is to create a new one in an existing directory.

==== git init

Upang kumuha ng isang direktoryo at i-on ito sa isang bagong Git repository upang maaari mong simulan ang bersyon na pagkontrol nito, maaari mo lamang patakbuhin ang git init.

Una naming ipakilala ito sa << _ git_basics_chapter # _getting_a_repo >>, kung saan ipinapakita namin ang paglikha ng isang bagong repository upang magsimulang magtrabaho kasama.

To take a directory and turn it into a new Git repository so you can start version controlling it, you can simply run `git init`.

We first introduce this in <<_git_basics_chapter#_getting_a_repo>>, where we show creating a brand new repository to start working with.

Nakikipag-usap kami nang maikli kung paano mo mababago ang default branch mula sa `` master '' sa << _ git_branching # _remote_branches >>.

We talk briefly about how you can change the default branch from ``master'' in <<_git_branching#_remote_branches>>.

Ginagamit namin ang command na ito upang lumikha ng isang walang laman na repository na walang laman para sa isang server sa << _ git_on_the_server # _bare_repo >>.
We use this command to create an empty bare repository for a server in <<_git_on_the_server#_bare_repo>>.

Sa wakas, pumunta kami sa ilang mga detalye ng kung ano talaga ang ginagawa nito sa likod ng mga eksena sa << _ git_internals # _plumbing_porcelain >>.
Finally, we go through some of the details of what it actually does behind the scenes in <<_git_internals#_plumbing_porcelain>>.

==== git clone

The `git clone` command is actually something of a wrapper around several other commands.
It creates a new directory, goes into it and runs `git init` to make it an empty Git repository, adds a remote (`git remote add`) to the URL that you pass it (by default named `origin`), runs a `git fetch` from that remote repository and then checks out the latest commit into your working directory with `git checkout`.

The `git clone` command is used in dozens of places throughout the book, but we'll just list a few interesting places.

It's basically introduced and explained in <<_git_basics_chapter#_git_cloning>>, where we go through a few examples.

In <<_git_on_the_server#_getting_git_on_a_server>> we look at using the `--bare` option to create a copy of a Git repository with no working directory.

In <<_git_tools#_bundling>> we use it to unbundle a bundled Git repository.

Finally, in <<_git_tools#_cloning_submodules>> we learn the `--recurse-submodules` option to make cloning a repository with submodules a little simpler.

Though it's used in many other places through the book, these are the ones that are somewhat unique or where it is used in ways that are a little different.


=== Basic Snapshotting
Para sa mga pangunahing daloy ng trabaho ng nilalaman ng pagtatanghal ng dula at gumawa ito sa iyong kasaysayan, mayroon lamang ng ilang mga pangunahing utos.
For the basic workflow of staging content and committing it to your history, there are only a few basic commands.

==== git add
Ang `git add` command ay nagdaragdag ng nilalaman mula sa nagtatrabaho na direktoryo sa lugar ng pagtatanghal ng dula (o" index ") para sa susunod na gumawa.
Kapag ang pagpapatupad ng `git commit` ay tumakbo, sa pamamagitan ng default ay tinitingnan lamang nito ang lugar ng pagtatanghal na ito, kaya ang` git add` ay ginagamit upang gawing eksakto kung ano ang nais mong gawin ang iyong susunod na gumawa ng snapshot.
The `git add` command adds content from the working directory into the staging area (or ``index'') for the next commit.
When the `git commit` command is run, by default it only looks at this staging area, so `git add` is used to craft what exactly you would like your next commit snapshot to look like.

Ang utos na ito ay isang hindi kapani-paniwalang mahalagang utos sa Git at binanggit o ginamit dose-dosenang beses sa aklat na ito.
Mabilis naming saklawin ang ilan sa mga natatanging gamit na maaaring matagpuan.
This command is an incredibly important command in Git and is mentioned or used dozens of times in this book.
We'll quickly cover some of the unique uses that can be found.

Una naming ipinakilala at ipaliwanag ang `git add` nang detalyado sa << _ git_basics_chapter # _tracking_files >>.
We first introduce and explain `git add` in detail in <<_git_basics_chapter#_tracking_files>>.

Binabanggit namin kung paano gamitin ito upang malutas ang pagsasalungat sa pagsasama sa << _ git_branching # _basic_merge_conflicts >>.
We mention how to use it to resolve merge conflicts in <<_git_branching#_basic_merge_conflicts>>.

Pumunta kami sa paglipas ng paggamit nito upang interactively yugto lamang ang mga tukoy na bahagi ng isang nabagong file sa << _ git_tools # _interactive_staging >>.
We go over using it to interactively stage only specific parts of a modified file in <<_git_tools#_interactive_staging>>.

Sa wakas, sundin namin ito sa isang mababang antas sa << _ git_internals # _tree_objects >>, kaya makakakuha ka ng ideya kung ano ang ginagawa nito sa likod ng mga eksena.
Finally, we emulate it at a low level in <<_git_internals#_tree_objects>>, so you can get an idea of what it's doing behind the scenes.

==== git status

Ipapakita sa iyo ng `git status` na utos ang iba't ibang mga estado ng mga file sa iyong nagtatrabaho na direktoryo at lugar ng pagtatanghal ng dula.
Aling mga file ay binago at unstaged at kung saan itinanghal ngunit hindi pa nakatuon.
Sa normal na anyo nito, ipapakita rin nito sa iyo ang ilang mga pangunahing pahiwatig kung paano maglipat ng mga file sa pagitan ng mga yugtong ito.
The `git status` command will show you the different states of files in your working directory and staging area.
Which files are modified and unstaged and which are staged but not yet committed.
In its normal form, it also will show you some basic hints on how to move files between these stages.

Unang sinasakop natin ang `status` sa << _ git_basics_chapter # _checking_status >>, kapwa sa mga batayan at pinadali ng mga form nito.
Habang ginagamit namin ito sa buong libro, medyo magkano ang lahat ng iyong magagawa sa `git katayuan` utos ay sakop doon.
We first cover `status` in <<_git_basics_chapter#_checking_status>>, both in its basic and simplified forms.
While we use it throughout the book, pretty much everything you can do with the `git status` command is covered there.

==== git diff
Ang command ng `git diff` ay ginagamit kapag nais mong makita ang mga pagkakaiba sa pagitan ng anumang dalawang puno.
Ito ay maaaring ang pagkakaiba sa pagitan ng iyong working environment at ang iyong lugar ng pagtatanghal (`git diff` mismo), sa pagitan ng iyong lugar ng pagtatanghal ng dula at ang iyong huling gumawa (` git diff --staged`), o sa pagitan ng dalawang gumawa (`git diff master branchB `).
The `git diff` command is used when you want to see differences between any two trees.
This could be the difference between your working environment and your staging area (`git diff` by itself), between your staging area and your last commit (`git diff --staged`), or between two commits (`git diff master branchB`).

Inaasahan muna namin ang mga pangunahing paggamit ng `git diff` sa << _ git_basics_chapter # _git_diff_staged >>, kung saan ipinapakita namin kung paano makita kung ano ang mga pagbabago ay itinanghal at hindi pa itinanghal.
We first look at the basic uses of `git diff` in <<_git_basics_chapter#_git_diff_staged>>, where we show how to see what changes are staged and which are not yet staged.

Ginagamit namin ito upang tumingin para sa posibleng mga isyu sa whitespace bago gumawa ng `- tseke` na opsyon sa << _ distributed_git # _commit_guidelines >>.
We use it to look for possible whitespace issues before committing with the `--check` option in <<_distributed_git#_commit_guidelines>>.


Nakita namin kung paano masuri ang mga pagkakaiba sa pagitan ng mga sanga nang mas epektibo sa `git diff A ... B` syntax sa << _ distributed_git # _what_is_introduced >>.We see how to check the differences between branches more effectively with the `git diff A...B` syntax in <<_distributed_git#_what_is_introduced>>.

Ginagamit namin ito upang i-filter ang mga pagkakaiba sa whitespace sa `-b` at kung paano ihambing ang iba't ibang yugto ng mga magkakasalungatang mga file gamit ang` --theirs`, `--ours` at` --base` sa << _ git_tools # _advanced_merging >>.
We use it to filter out whitespace differences with `-b` and how to compare different stages of conflicted files with `--theirs`, `--ours` and `--base` in <<_git_tools#_advanced_merging>>.

Sa wakas, ginagamit namin ito upang epektibong ihambing ang mga pagbabago sa submodule sa `--submodule` sa << _ git_tools # _starting_submodules >>.
Finally, we use it to effectively compare submodule changes with `--submodule` in <<_git_tools#_starting_submodules>>.

==== git difftool

The `git difftool` command simply launches an external tool to show you the difference between two trees in case you want to use something other than the built in `git diff` command.

We only briefly mention this in <<_git_basics_chapter#_git_diff_staged>>.
Ang git difftool command ay naglulunsad lamang ng isang panlabas na tool upang ipakita sa iyo ang pagkakaiba sa pagitan ng dalawang puno kung sakaling gusto mong gumamit ng iba pang bagay kaysa sa built in na git diff command.
Binanggit lang namin ito sa _git_basics_chapter.asc.
==== git commit

The `git commit` command takes all the file contents that have been staged with `git add` and records a new permanent snapshot in the database and then moves the branch pointer on the current branch up to it.
Ang git gumawa command ay tumatagal ng lahat ng mga nilalaman ng file na itinanghal sa git add at nagtatala ng isang bagong permanenteng snapshot sa database at pagkatapos ay inililipat ang branch pointer sa kasalukuyang sangay hanggang dito.

We first cover the basics of committing in <<_git_basics_chapter#_committing_changes>>.
There we also demonstrate how to use the `-a` flag to skip the `git add` step in daily workflows and how to use the `-m` flag to pass a commit message in on the command line instead of firing up an editor.
Unang sinaklaw natin ang mga pangunahing kaalaman sa paggawa sa _git_basics_chapter.asc. Ipinakita din namin kung paano gamitin ang-isang bandila upang laktawan ang git magdagdag ng hakbang sa araw-araw na daloy ng trabaho at kung paano gamitin ang -m flag upang pumasa ng isang gumawa ng mensahe sa sa command line sa halip ng pagpapaputok ng isang editor.

In <<_git_basics_chapter#_undoing>> we cover using the `--amend` option to redo the most recent commit.
Sa _git_basics_chapter.asc tinatakpan namin ang paggamit ng --amam na opsyon upang gawing muli ang pinakabagong gawa.

In <<_git_branching#_git_branches_overview>>, we go into much more detail about what `git commit` does and why it does it like that.
Sa _git_branching.asc, pumunta kami sa mas maraming detalye tungkol sa kung ano ang ginagawa ng git at kung bakit ginagawa nito ito.

We looked at how to sign commits cryptographically with the `-S` flag in <<_git_tools#_signing_commits>>.
Tiningnan namin kung paano mag-sign magawa ng cryptographically kasama ang -S flag sa _git_tools.asc.

Finally, we take a look at what the `git commit` command does in the background and how it's actually implemented in <<_git_internals#_git_commit_objects>>.
Sa wakas, tinitingnan natin kung ano ang ginagawa ng git commit sa background at kung paano ito aktwal na ipinatupad sa _git_internals.asc.

==== git reset

The `git reset` command is primarily used to undo things, as you can possibly tell by the verb.
It moves around the `HEAD` pointer and optionally changes the `index` or staging area and can also optionally change the working directory if you use `--hard`.
This final option makes it possible for this command to lose your work if used incorrectly, so make sure you understand it before using it.
Ang utos ng pag-reset ng git ay pangunahing ginagamit upang i-undo ang mga bagay, dahil maaari mong sabihin sa pamamagitan ng pandiwa. Ito ay gumagalaw sa paligid ng HEAD pointer at opsyonal na nagbabago sa index o staging area at maaari ring opsyonal na baguhin ang nagtatrabaho direktoryo kung gagamitin mo - hard. Ang pangwakas na opsyon ay ginagawang posible para sa command na ito na mawala ang iyong trabaho kung ginamit nang hindi tama, kaya tiyaking maunawaan mo ito bago gamitin ito.

We first effectively cover the simplest use of `git reset` in <<_git_basics_chapter#_unstaging>>, where we use it to unstage a file we had run `git add` on.
Una naming epektibong sinasakop ang pinakasimpleng paggamit ng git reset sa _git_basics_chapter.asc, kung saan ginagamit namin ito upang unstage isang file na kami ay tumakbo git idagdag sa.

We then cover it in quite some detail in <<_git_tools#_git_reset>>, which is entirely devoted to explaining this command.
Pagkatapos ay tinatakpan namin ito sa lubos na detalye sa _git_tools.asc, na lubos na nakatuon sa pagpapaliwanag sa utos na ito.

We use `git reset --hard` to abort a merge in <<_git_tools#_abort_merge>>, where we also use `git merge --abort`, which is a bit of a wrapper for the `git reset` command.
Ginagamit namin ang git reset - hard upang i-abort ang isang sumanib sa _git_tools.asc, kung saan ginagamit din namin ang git merge --abort, na kung saan ay isang bit ng wrapper para sa git reset command.

==== git rm

The `git rm` command is used to remove files from the staging area and working directory for Git.
It is similar to `git add` in that it stages a removal of a file for the next commit.
Ang git rm command ay ginagamit upang tanggalin ang mga file mula sa lugar ng pagtatanghal ng dula at nagtatrabaho direktoryo para sa Git. Ito ay katulad ng git add sa na ito ay nagsisimula ng pagtanggal ng isang file para sa susunod na gumawa.

We cover the `git rm` command in some detail in <<_git_basics_chapter#_removing_files>>, including recursively removing files and only removing files from the staging area but leaving them in the working directory with `--cached`.
Sinasaklaw namin ang command na `git rm` sa ilang detalye sa << _ git_basics_chapter # _removing_files >>, kabilang ang recursively pag-alis ng mga file at pag-aalis lamang ng mga file mula sa lugar ng pagtatanghal ng dula ngunit iniiwan ang mga ito sa nagtatrabaho na direktoryo na may` - cached`.

The only other differing use of `git rm` in the book is in <<_git_internals#_removing_objects>> where we briefly use and explain the `--ignore-unmatch` when running `git filter-branch`, which simply makes it not error out when the file we are trying to remove doesn't exist.
This can be useful for scripting purposes.
Ang tanging iba pang magkakaibang paggamit ng `git rm` sa aklat ay nasa << _ git_internals # _removing_objects >> kung saan ginagamit namin ng maikli at ipapaliwanag ang` --ignore-unmatch` kapag nagpapatakbo ng `git filter-branch`, na kung saan ay simpleng hindi ito error kapag ang file na sinusubukan naming tanggalin ay hindi umiiral.
Maaari itong maging kapaki-pakinabang para sa mga layunin ng pag-script.

==== git mv

The `git mv` command is a thin convenience command to move a file and then run `git add` on the new file and `git rm` on the old file.
Ang command na `git mv` ay isang manipis na kaginhawahan na utos upang maglipat ng isang file at pagkatapos ay patakbuhin ang` git add` sa bagong file at `git rm` sa lumang file.

We only briefly mention this command in <<_git_mv>>.
Binanggit lamang namin nang maikli ang utos na ito sa << _ git_mv >>.

==== git clean

The `git clean` command is used to remove unwanted files from your working directory.
This could include removing temporary build artifacts or merge conflict files.
Ang `git clean` command ay ginagamit upang tanggalin ang mga hindi gustong file mula sa iyong nagtatrabaho na direktoryo.
Maaaring kabilang dito ang pag-alis ng pansamantalang mga artifact build o pagsamahin ang mga file ng conflict.

We cover many of the options and scenarios in which you might used the clean command in <<_git_clean>>.
Sinasaklaw namin ang marami sa mga pagpipilian at sitwasyon kung saan maaari mong gamitin ang malinis na utos sa << _ git_clean >>.

=== Branching and Merging

There are just a handful of commands that implement most of the branching and merging functionality in Git.
Mayroong isang maliit na bilang ng mga utos na nagpapatupad ng karamihan sa pagsasanib at pagsasama ng pag-andar sa Git.

==== git branch

The `git branch` command is actually something of a branch management tool.
It can list the branches you have, create a new branch, delete branches and rename branches.
Ang `git branch` command ay talagang isang bagay ng isang tool sa pamamahala ng sangay.
Maaari itong ilista ang mga sangay na mayroon ka, lumikha ng isang bagong sangay, tanggalin ang mga sanga at palitan ang pangalan ng mga sanga.

Most of <<_git_branching#_git_branching>> is dedicated to the `branch` command and it's used throughout the entire chapter.
We first introduce it in <<_git_branching#_create_new_branch>> and we go through most of its other features (listing and deleting) in <<_git_branching#_branch_management>>.
Karamihan ng << _ git_branching # _git_branching >> ay nakatuon sa command na 'branch` at ginagamit ito sa buong kabanata.
Una naming ipakilala ito sa << _ git_branching # _create_new_branch >> at kami ay dumadaan sa karamihan ng iba pang mga tampok nito (listahan at pagtanggal) sa << _ git_branching # _branch_management >>.

In <<_git_branching#_tracking_branches>> we use the `git branch -u` option to set up a tracking branch.
Sa << _ git_branching # _tracking_branches >> ginagamit namin ang `git branch -u` na pagpipilian upang mag-set up ng isang sangay sa pagsubaybay.

Finally, we go through some of what it does in the background in <<_git_internals#_git_refs>>.
Sa wakas, pumunta kami sa ilan sa kung ano ang ginagawa nito sa background sa << _ git_internals # _git_refs >>.

==== git checkout

The `git checkout` command is used to switch branches and check content out into your working directory.
Ang command na `git checkout` ay ginagamit upang lumipat ng mga sanga at suriin ang nilalaman sa iyong nagtatrabaho na direktoryo.

We first encounter the command in <<_git_branching#_switching_branches>> along with the `git branch` command.
Una naming nakatagpo ang command sa << _ git_branching # _switching_branches >> kasama ang command na `git branch`.

We see how to use it to start tracking branches with the `--track` flag in <<_git_branching#_tracking_branches>>.
Nakita namin kung paano gamitin ito upang simulan ang pagsubaybay ng mga sanga gamit ang `--track` flag sa << _ git_branching # _tracking_branches >>.

We use it to reintroduce file conflicts with `--conflict=diff3` in <<_git_tools#_checking_out_conflicts>>.
Ginagamit namin ito upang maipakita muli ang mga kontrahan ng file sa `--conflict = diff3` sa << _ git_tools # _checking_out_conflicts >>.

We go into closer detail on its relationship with `git reset` in <<_git_tools#_git_reset>>.
Pumunta kami sa mas detalyadong detalye sa kaugnayan nito sa `git reset` sa << _ git_tools # _git_reset >>.

Finally, we go into some implementation detail in <<_git_internals#_the_head>>.
Sa wakas, pumunta kami sa ilang detalye ng pagpapatupad sa << _ git_internals # _the_head >>.

==== git merge

The `git merge` tool is used to merge one or more branches into the branch you have checked out.
It will then advance the current branch to the result of the merge.
Ang tool na `git merge` ay ginagamit upang pagsamahin ang isa o higit pang mga sangay sa sangay na iyong sinuri.
Susubukan nito ang kasalukuyang sangay sa resulta ng pagsasama.

The `git merge` command was first introduced in <<_git_branching#_basic_branching>>.
Though it is used in various places in the book, there are very few variations of the `merge` command -- generally just `git merge <branch>` with the name of the single branch you want to merge in.
Ang `git merge` command ay unang ipinakilala sa << _ git_branching # _basic_branching >>.
Kahit na ito ay ginagamit sa iba't ibang mga lugar sa aklat, napakakaunting mga pagkakaiba-iba ng 'merge` command - sa pangkalahatan lamang `git pagsamahin <branch>` na may pangalan ng solong sangay na nais mong pagsamahin.

We covered how to do a squashed merge (where Git merges the work but pretends like it's just a new commit without recording the history of the branch you're merging in) at the very end of <<_distributed_git#_public_project>>.
Tinakpan namin kung paano gumawa ng isang nakakulong na pagsasama (kung saan ang Git ay nagpahiwatig ng trabaho ngunit nagpapanggap na tulad ng isang bagong komit na hindi naitala ang kasaysayan ng sangay na pinagsasama mo) sa dulo ng << _ distributed_git # _public_project >>.

We went over a lot about the merge process and command, including the `-Xignore-space-change` command and the `--abort` flag to abort a problem merge in <<_git_tools#_advanced_merging>>.
Nagpunta kami ng maraming tungkol sa proseso ng pagsasama at utos, kabilang ang `-Xignore-space-change` command at ang` --abort` flag upang i-abort ang problema sa pagsasama sa << _ git_tools # _advanced_merging >>.

We learned how to verify signatures before merging if your project is using GPG signing in <<_git_tools#_signing_commits>>.
Natutunan namin kung paano i-verify ang mga lagda bago pagsasama kung ang iyong proyekto ay gumagamit ng pag-sign GPG sa << _ git_tools # _signing_commits >>.

Finally, we learned about Subtree merging in <<_git_tools#_subtree_merge>>.
Sa wakas, natutunan namin ang tungkol sa pagsasama ng Subtree sa << _ git_tools # _subtree_merge >>.

==== git mergetool

The `git mergetool` command simply launches an external merge helper in case you have issues with a merge in Git.
Ang `git mergetool` utos ay naglulunsad lamang ng isang panlabas na merge helper kung sakaling mayroon kang mga isyu sa isang pagsali sa Git.

We mention it quickly in <<_git_branching#_basic_merge_conflicts>> and go into detail on how to implement your own external merge tool in <<_customizing_git#_external_merge_tools>>.
Binanggit namin ito nang mabilis sa << _ git_branching # _basic_merge_conflicts >> at pumunta sa detalye kung paano ipatupad ang iyong sariling panlabas na tool sa pagsasama sa << _ customizing_git # _external_merge_tools >>.

==== git log

The `git log` command is used to show the reachable recorded history of a project from the most recent commit snapshot backwards.
By default it will only show the history of the branch you're currently on, but can be given different or even multiple heads or branches from which to traverse.
It is also often used to show differences between two or more branches at the commit level.

This command is used in nearly every chapter of the book to demonstrate the history of a project.

We introduce the command and cover it in some depth in <<_git_basics_chapter#_viewing_history>>.
There we look at the `-p` and `--stat` option to get an idea of what was introduced in each commit and the `--pretty` and `--oneline` options to view the history more concisely, along with some simple date and author filtering options.

In <<_git_branching#_create_new_branch>> we use it with the `--decorate` option to easily visualize where our branch pointers are located and we also use the `--graph` option to see what divergent histories look like.

In <<_distributed_git#_private_team>> and <<_git_tools#_commit_ranges>> we cover the `branchA..branchB` syntax to use the `git log` command to see what commits are unique to a branch relative to another branch.
In <<_git_tools#_commit_ranges>> we go through this fairly extensively.

In <<_git_tools#_merge_log>> and <<_git_tools#_triple_dot>> we cover using the `branchA...branchB` format and the `--left-right` syntax to see what is in one branch or the other but not in both.
In <<_git_tools#_merge_log>> we also look at how to use the `--merge` option to help with merge conflict debugging as well as using the `--cc` option to look at merge commit conflicts in your history.

In <<_git_reflog>> we use the `-g` option to view the Git reflog through this tool instead of doing branch traversal.

In <<_git_tools#_searching>> we look at using the `-S` and `-L` options to do fairly sophisticated searches for something that happened historically in the code such as seeing the history of a function.

In <<_git_tools#_signing_commits>> we see how to use `--show-signature` to add a validation string to each commit in the `git log` output based on if it was validly signed or not.

==== git stash

The `git stash` command is used to temporarily store uncommitted work in order to clean out your working directory without having to commit unfinished work on a branch.

This is basically entirely covered in <<_git_tools#_git_stashing>>.

==== git tag

The `git tag` command is used to give a permanent bookmark to a specific point in the code history.
Generally this is used for things like releases.

This command is introduced and covered in detail in <<_git_basics_chapter#_git_tagging>> and we use it in practice in <<_distributed_git#_tagging_releases>>.

We also cover how to create a GPG signed tag with the `-s` flag and verify one with the `-v` flag in <<_git_tools#_signing>>.


=== Sharing and Updating Projects

There are not very many commands in Git that access the network, nearly all of the commands operate on the local database.
When you are ready to share your work or pull changes from elsewhere, there are a handful of commands that deal with remote repositories.

==== git fetch

The `git fetch` command communicates with a remote repository and fetches down all the information that is in that repository that is not in your current one and stores it in your local database.

We first look at this command in <<_git_basics_chapter#_fetching_and_pulling>> and we continue to see examples of it use in <<_git_branching#_remote_branches>>.

We also use it in several of the examples in <<_distributed_git#_contributing_project>>.

We use it to fetch a single specific reference that is outside of the default space in <<_github#_pr_refs>> and we see how to fetch from a bundle in <<_git_tools#_bundling>>.

We set up highly custom refspecs in order to make `git fetch` do something a little different than the default in <<_git_internals#_refspec>>.

==== git pull

The `git pull` command is basically a combination of the `git fetch` and `git merge` commands, where Git will fetch from the remote you specify and then immediately try to merge it into the branch you're on.

We introduce it quickly in <<_git_basics_chapter#_fetching_and_pulling>> and show how to see what it will merge if you run it in <<_git_basics_chapter#_inspecting_remote>>.

We also see how to use it to help with rebasing difficulties in <<_git_branching#_rebase_rebase>>.

We show how to use it with a URL to pull in changes in a one-off fashion in <<_distributed_git#_checking_out_remotes>>.

Finally, we very quickly mention that you can use the `--verify-signatures` option to it in order to verify that commits you are pulling have been GPG signed in <<_git_tools#_signing_commits>>.

==== git push

The `git push` command is used to communicate with another repository, calculate what your local database has that the remote one does not, and then pushes the difference into the other repository.
It requires write access to the other repository and so normally is authenticated somehow.

We first look at the `git push` command in <<_git_basics_chapter#_pushing_remotes>>.
Here we cover the basics of pushing a branch to a remote repository.
In <<_git_branching#_pushing_branches>> we go a little deeper into pushing specific branches and in <<_git_branching#_tracking_branches>> we see how to set up tracking branches to automatically push to.
In <<_git_branching#_delete_branches>> we use the `--delete` flag to delete a branch on the server with `git push`.

Throughout <<_distributed_git#_contributing_project>> we see several examples of using `git push` to share work on branches through multiple remotes.

We see how to use it to share tags that you have made with the `--tags` option in <<_git_basics_chapter#_sharing_tags>>.

In <<_git_tools#_publishing_submodules>> we use the `--recurse-submodules` option to check that all of our submodules work has been published before pushing the superproject, which can be really helpful when using submodules.

In <<_customizing_git#_other_client_hooks>> we talk briefly about the `pre-push` hook, which is a script we can setup to run before a push completes to verify that it should be allowed to push.

Finally, in <<_git_internals#_pushing_refspecs>> we look at pushing with a full refspec instead of the general shortcuts that are normally used.
This can help you be very specific about what work you wish to share.

==== git remote

The `git remote` command is a management tool for your record of remote repositories.
It allows you to save long URLs as short handles, such as ``origin'' so you don't have to type them out all the time.
You can have several of these and the `git remote` command is used to add, change and delete them.

This command is covered in detail in <<_git_basics_chapter#_remote_repos>>, including listing, adding, removing and renaming them.

It is used in nearly every subsequent chapter in the book too, but always in the standard `git remote add <name> <url>` format.

==== git archive

The `git archive` command is used to create an archive file of a specific snapshot of the project.

We use `git archive` to create a tarball of a project for sharing in <<_distributed_git#_preparing_release>>.

==== git submodule

The `git submodule` command is used to manage external repositories within a normal repositories.
This could be for libraries or other types of shared resources.
The `submodule` command has several sub-commands (`add`, `update`, `sync`, etc) for managing these resources.

This command is only mentioned and entirely covered in <<_git_tools#_git_submodules>>.

=== Inspection and Comparison

==== git show

The `git show` command can show a Git object in a simple and human readable way.
Normally you would use this to show the information about a tag or a commit.

We first use it to show annotated tag information in <<_git_basics_chapter#_annotated_tags>>.

Later we use it quite a bit in <<_git_tools#_revision_selection>> to show the commits that our various revision selections resolve to.

One of the more interesting things we do with `git show` is in <<_git_tools#_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

==== git shortlog

The `git shortlog` command is used to summarize the output of `git log`.
It will take many of the same options that the `git log` command will but instead of listing out all of the commits it will present a summary of the commits grouped by author.

We showed how to use it to create a nice changelog in <<_distributed_git#_the_shortlog>>.

==== git describe

The `git describe` command is used to take anything that resolves to a commit and produces a string that is somewhat human-readable and will not change.
It's a way to get a description of a commit that is as unambiguous as a commit SHA-1 but more understandable.

We use `git describe` in <<_distributed_git#_build_number>> and <<_distributed_git#_preparing_release>> to get a string to name our release file after.


=== Debugging

Git has a couple of commands that are used to help debug an issue in your code.
This ranges from figuring out where something was introduced to figuring out who introduced it.

==== git bisect

The `git bisect` tool is an incredibly helpful debugging tool used to find which specific commit was the first one to introduce a bug or problem by doing an automatic binary search.

It is fully covered in <<_git_tools#_binary_search>> and is only mentioned in that section.

==== git blame

The `git blame` command annotates the lines of any file with which commit was the last one to introduce a change to each line of the file and what person authored that commit.
This is helpful in order to find the person to ask for more information about a specific section of your code.

It is covered in <<_git_tools#_file_annotation>> and is only mentioned in that section.

==== git grep

The `git grep` command can help you find any string or regular expression in any of the files in your source code, even older versions of your project.

It is covered in <<_git_grep>> and is only mentioned in that section.

=== Patching

A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
These commands help you manage your branches in this manner.

==== git cherry-pick

The `git cherry-pick` command is used to take the change introduced in a single Git commit and try to re-introduce it as a new commit on the branch you're currently on.
This can be useful to only take one or two commits from a branch individually rather than merging in the branch which takes all the changes.

Cherry picking is described and demonstrated in <<_distributed_git#_rebase_cherry_pick>>.

==== git rebase

The `git rebase` command is basically an automated `cherry-pick`.
It determines a series of commits and then cherry-picks them one by one in the same order somewhere else.

Rebasing is covered in detail in <<_git_branching#_rebasing>>, including covering the collaborative issues involved with rebasing branches that are already public.

We use it in practice during an example of splitting your history into two separate repositories in <<_git_tools#_replace>>, using the `--onto` flag as well.

We go through running into a merge conflict during rebasing in <<_git_tools#_rerere>>.

We also use it in an interactive scripting mode with the `-i` option in <<_git_tools#_changing_multiple>>.

==== git revert

The `git revert` command is essentially a reverse `git cherry-pick`.
It creates a new commit that applies the exact opposite of the change introduced in the commit you're targeting, essentially undoing or reverting it.

We use this in <<_git_tools#_reverse_commit>> to undo a merge commit.

=== Email

Many Git projects, including Git itself, are entirely maintained over mailing lists.
Git has a number of tools built into it that help make this process easier, from generating patches you can easily email to applying those patches from an email box.

==== git apply

The `git apply` command applies a patch created with the `git diff` or even GNU diff command.
It is similar to what the `patch` command might do with a few small differences.

We demonstrate using it and the circumstances in which you might do so in <<_distributed_git#_patches_from_email>>.

==== git am

The `git am` command is used to apply patches from an email inbox, specifically one that is mbox formatted.
This is useful for receiving patches over email and applying them to your project easily.

We covered usage and workflow around `git am` in <<_git_am>> including using the `--resolved`, `-i` and `-3` options.

There are also a number of hooks you can use to help with the workflow around `git am` and they are all covered in <<_customizing_git#_email_hooks>>.

We also use it to apply patch formatted GitHub Pull Request changes in <<_github#_email_notifications>>.

==== git format-patch

The `git format-patch` command is used to generate a series of patches in mbox format that you can use to send to a mailing list properly formatted.

We go through an example of contributing to a project using the `git format-patch` tool in <<_distributed_git#_project_over_email>>.

==== git imap-send

The `git imap-send` command uploads a mailbox generated with `git format-patch` into an IMAP drafts folder.

We go through an example of contributing to a project by sending patches with the `git imap-send` tool in <<_distributed_git#_project_over_email>>.

==== git send-email

The `git send-email` command is used to send patches that are generated with `git format-patch` over email.

We go through an example of contributing to a project by sending patches with the `git send-email` tool in <<_distributed_git#_project_over_email>>.

==== git request-pull

The `git request-pull` command is simply used to generate an example message body to email to someone.
If you have a branch on a public server and want to let someone know how to integrate those changes without sending the patches over email, you can run this command and send the output to the person you want to pull the changes in.

We demonstrate how to use `git request-pull` to generate a pull message in <<_distributed_git#_public_project>>.

=== External Systems

Git comes with a few commands to integrate with other version control systems.

==== git svn

The `git svn` command is used to communicate with the Subversion version control system as a client.
This means you can use Git to checkout from and commit to a Subversion server.

This command is covered in depth in <<_git_svn>>.

==== git fast-import

For other version control systems or importing from nearly any format, you can use `git fast-import` to quickly map the other format to something Git can easily record.

This command is covered in depth in <<_git_and_other_systems#_custom_importer>>.

=== Administration

If you're administering a Git repository or need to fix something in a big way, Git provides a number of administrative commands to help you out.

==== git gc

The `git gc` command runs ``garbage collection'' on your repository, removing unnecessary files in your database and packing up the remaining files into a more efficient format.

This command normally runs in the background for you, though you can manually run it if you wish.
We go over some examples of this in <<_git_gc>>.

==== git fsck

The `git fsck` command is used to check the internal database for problems or inconsistencies.

We only quickly use this once in <<_git_internals#_data_recovery>> to search for dangling objects.

==== git reflog

The `git reflog` command goes through a log of where all the heads of your branches have been as you work to find commits you may have lost through rewriting histories.

We cover this command mainly in <<_git_reflog>>, where we show normal usage to and how to use `git log -g` to view the same information with `git log` output.

We also go through a practical example of recovering such a lost branch in <<_git_internals#_data_recovery>>.

==== git filter-branch

The `git filter-branch` command is used to rewrite loads of commits according to certain patterns, like removing a file everywhere or filtering the entire repository down to a single subdirectory for extracting a project.

In <<_git_tools#_removing_file_every_commit>> we explain the command and explore several different options such as `--commit-filter`, `--subdirectory-filter` and `--tree-filter`.

In <<_git_and_other_systems#_git_p4>> and <<_git_and_other_systems#_git_tfs>> we use it to fix up imported external repositories.


=== Plumbing Commands

There were also quite a number of lower level plumbing commands that we encountered in the book.

The first one we encounter is `ls-remote` in <<_github#_pr_refs>> which we use to look at the raw references on the server.

We use `ls-files` in <<_git_tools#_manual_remerge>>, <<_git_tools#_rerere>> and <<_git_tools#_the_index>> to take a more raw look at what your staging area looks like.

We also mention `rev-parse` in <<_git_tools#_branch_references>> to take just about any string and turn it into an object SHA-1.

However, most of the low level plumbing commands we cover are in <<_git_internals#_git_internals>>, which is more or less what the chapter is focused on.
We tried to avoid use of them throughout most of the rest of the book.
