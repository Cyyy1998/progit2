=== Batayan ng Pag-branch at Pag-merge

Dumaan tayo patungo sa isang simpleng halimbawa ng pag-branch at pag-merge sa isang daloy ng trabaho na maaaring mong gamitin sa tunay na mundo. Susundin mo ang mga hakbang na ito:

. Magsagawa ng ilang trabaho sa isang website.
. Gumawa ng isang branch para sa isang panibagong kwento na iyong tinatrabaho.
. Magsagawa ng ilang trabaho sa branch na iyon.

Sa puntong ito, makakatanggap ka ng isang tawag na ang ibang isyu ay kritikal at kinakailangan mo ng isang hotfix. Gagawin mo ang sumusunod:

. Lumipat sa iyong produksyon na branch.
. Gumawa ng isang branch upang idagdag ang hotfix.
. Pagkatapos itong i-test, i-merge ang hotfix na branch, at i-push sa produksyon.
. Lumipat pabalik sa iyong orihinal na kwento at magpatuloy sa pagtrabaho.

[[_basic_branching]]
==== Batayan sa Pag-branch

(((mga branch, batay na daloy ng trabaho)))
Una, sabihin nating ikaw ay nagtatrabaho sa iyong proyekto at mayroon nang dalawang commit sa `master` na branch.

.Isang simpleng kasaysayan ng commit
image::images/basic-branching-1.png[Isang simpleng kasaysayan ng commit.]

Pinili mong magtrabaho sa isyu #53 sa anumang issue-tracking na sistema na ginagamit ng iyong kumpanya. Upang makagawa ng isang panibagong branch at lumipat dito sa parehong oras, maaari mong patakbuhin ang `git checkout` na utos na may `-b` na switch:

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

Ito ay takigrapya para sa:

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.Paggawa ng isang panibagong branch na pointer
image::images/basic-branching-2.png[Paggawa ng isang panibagong branch na pointer.]

Ikaw ay nagtatrabaho sa iyong website at gumawa ng ilang mga commit. Ang paggawa nito ay naglilipat sa `iss53` na branch nang pasulong, dahil na-check out mo ito (iyon ay, ang iyong `HEAD` ay nakaturo nito):

[source,console]
----
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
----

.Ang `iss53` na branch ay nailipat nang pasulong kasama ng iyong trabaho
image::images/basic-branching-3.png[Ang `iss53` na branch ay nailipat nang pasulong kasama ng iyong trabaho.]

Ngayon makukuha mo ang tawag na may isang isyu sa website, at kailangan mo itong ayusin kaagad. Gamit ang Git, hindi mo na kailangang i-deploy ang iyong pag-ayos kasama ang `iss53` na mga pagbabago na iyong ginawa, at hindi mo na kailangang maglagay ng maraming pagsisikap sa pagpapabalik ng mga pagbabagong iyon bago ka maaaring magtrabaho sa paglalapat ng iyong pag-ayos sa anumang nasa produksyon. Ang kailangan mo lang gawin ay lumipat pabalik sa iyong `master` na branch.

Subalit, bago mo gawin iyon, tandaan na kung ang iyong tinatrabaho na direktoryo o staging na lawak ay mayroong hindi naka-commit na mga pagbabago na salungat sa branch na iyong na-check out, Ang Git ay hindi ka hahayaang maglipat ng mga branch. Pinakamainam na magkaroon ng isang malinis na estado ng tinatrabaho kapag ikaw ay maglilipat ng mga branch. May mga paraan upang makaligtaan ito (katulad, ang pag-stash at pag-amend ng commit) na masasakop natin mamaya, sa <<_git_tools#_git_stashing>>. Sa ngayon, ipalagay natin na na-commit mo na lahat ang iyong mga pagbabago, kaya maaari ka nang lumipat pabalik sa iyong `master` na branch:

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

Sa puntong ito, ang iyong tinatrabaho na direktoryo ng iyong proyekto ay eksakto kung paano ito bago mo sinimulang magtrabaho sa isyu #53, at maaari mo nang pag-isiping mabuti ang iyong hotfix. Ito ay isang importanteng punto na dapat tandaan: kapag ikaw ay maglilipat ng mga branch, ang Git ay ire-reset ang iyong tinatrabaho na direktoryo upang magmukha itong kagaya sa huling pagkakataon na ikaw ay nag-commit sa branch na iyon. Ito ay awtomatikong nagdaragdag, nagtatanggal, at nagbabago ng mga files upang siguraduhing ang iyong tinatrabaho na kopya ay kagaya ng kung ano ang mukha ng branch sa iyong huling commit.

Susunod, mayroon kang isang hotfix na gagawin. Gumawa tayo ng isang `hotfix` na branch kung saan tatrabahuin hanggang sa ito ay matapos:

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
----

.Ang Hotfix na branch ay nakabatay sa `master`
image::images/basic-branching-4.png[Ang Hotfix na branch ay nakabatay sa `master`.]

Maaari mong patakbuhin ang iyong mga test, siguraduhing ang hotfix ay kung ano ang iyong gusto, at sa wakas i-merge ang `hotfix` na branch pabalik sa iyong `master` na branch upang i-deploy sa produksyon. Gawin mo ito gamit ang `git merge` na utos:(((git commands, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

Mapapansin mo ang pariral na ``fast-forward'' sa merge na iyon. Dahil ang commit na `C4` na itinuro ng `hotfix` na branch na iyong na-merge in ay direktang nauuna sa `C2` na commit kung saan nandoon ka, ang Git ay simpleng ililipat ang pointer nang pasulong. Upang ipahayag iyon sa ibang paraan, kapag sinubukan mong i-merge ang isang commit sa isang pang commit na maaaring maabot sa pamamagitan ng pagsunod sa kasaysayan ng unang commit, ang Git ay pinapasimple ang mga bagay sa pamamagitan ng paglipat ng pointer nang pasulong dahil walang magkakaibang trabaho na sama-samang i-merge -- ito ay tinatawag na isang ``fast-forward.''

Ang iyong pagbabago ay nasa snapshot na ngayon ng commit na itinuro ng `master` na branch, at maaari mong i-deploy ang fix.

.Ang `master` ay na-fast-forward sa `hotfix`
image::images/basic-branching-5.png[Ang `master` ay na-fast-forward sa `hotfix`.]

Pagkatapos ma-deploy ang iyong sobrang importanteng pag-ayos, handa ka nang lumipat pabalik sa trabahong ginagawa mo dati bago ka naabala. Ngunit, una ay burahin mo ang `hotfix` na branch, dahil hindi mo na kailangan ito -- ang `master` na branch ay nakaturo sa parehong lugar. Maaari mong burahin ito gamit ang `-d` na opsyon sa `git branch`:

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

Ngayon maaari ka nang lumipat pabalik sa iyong work-in-progress na branch sa isyu #53 at magpatuloy sa pagtrabaho nito.

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.Ang trabaho ay magpapatuloy sa `iss53`
image::images/basic-branching-6.png[Ang trabaho ay magpapatuloy sa `iss53`.]

Mahalagang tandaan dito na ang trabaho na iyong ginawa sa iyong `hotfix` na branch ay hindi nilalaman sa mga file sa iyong `iss53` na branch. Kung kailangan mong i-pull ito, maaari mong i-merge ang iyong `master` na branch sa iyong `iss53` na branch sa pagpapatakbo ng `git merge master`, o maaari kang maghintay na pagsamahin ang mga pagbabagong iyon hanggang ikaw ay makapagpasya na i-pull ang `iss53` na branch pabalik sa `master` mamaya.

[[_basic_merging]]
==== Batayan ng Pag-merge

(((mga branch, pag-merge)))(((pag-merge)))
Mangyaring ikaw ay nakapagpasya na ang iyong isyu #53 na trabaho ay natapos at handa nang i-merge sa iyong `master` na branch. Upang magawa iyon, ime-merge mo ang iyong `iss53` na branch sa `master`, masyadong katulad ng pag-merge mo sa iyong `hotfix` na branch kamakailan lamang. Ang kailangan mo lamang gawin ay i-check out ang branch na gusto mong i-merge at pagkatapos ay patakbuhin ang `git merge` na utos:

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
----

This looks a bit different than the `hotfix` merge you did earlier.
In this case, your development history has diverged from some older point.
Because the commit on the branch you're on isn't a direct ancestor of the branch you're merging in, Git has to do some work.
In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two.

.Three snapshots used in a typical merge
image::images/basic-merging-1.png[Three snapshots used in a typical merge.]

Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it.
This is referred to as a merge commit, and is special in that it has more than one parent.

.A merge commit
image::images/basic-merging-2.png[A merge commit.]

It's worth pointing out that Git determines the best common ancestor to use for its merge base; this is different than older tools like CVS or Subversion (before version 1.5), where the developer doing the merge had to figure out the best merge base for themselves.
This makes merging a heck of a lot easier in Git than in these other systems.

Now that your work is merged in, you have no further need for the `iss53` branch.
You can close the ticket in your ticket-tracking system, and delete the branch:

[source,console]
----
$ git branch -d iss53
----

[[_basic_merge_conflicts]]
==== Basic Merge Conflicts

(((merging, conflicts)))
Occasionally, this process doesn't go smoothly.
If you changed the same part of the same file differently in the two branches you're merging together, Git won't be able to merge them cleanly.
If your fix for issue #53 modified the same part of a file as the `hotfix` branch, you'll get a merge conflict that looks something like this:

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

Git hasn't automatically created a new merge commit.
It has paused the process while you resolve the conflict.
If you want to see which files are unmerged at any point after a merge conflict, you can run `git status`:

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

Anything that has merge conflicts and hasn't been resolved is listed as unmerged.
Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts.
Your file contains a section that looks something like this:

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

This means the version in `HEAD` (your `master` branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the `=======`), while the version in your `iss53` branch looks like everything in the bottom part.
In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself.
For instance, you might resolve this conflict by replacing the entire block with this:

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

This resolution has a little of each section, and the `<<<<<<<`, `=======`, and `>>>>>>>` lines have been completely removed.
After you've resolved each of these sections in each conflicted file, run `git add` on each file to mark it as resolved.
Staging the file marks it as resolved in Git.

If you want to use a graphical tool to resolve these issues, you can run `git mergetool`, which fires up an appropriate visual merge tool and walks you through the conflicts:(((git commands, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

If you want to use a merge tool other than the default (Git chose `opendiff` in this case because the command was run on a Mac), you can see all the supported tools listed at the top after ``one of the following tools.''
Just type the name of the tool you'd rather use.

[NOTE]
====
If you need more advanced tools for resolving tricky merge conflicts, we cover more on merging in <<_git_tools#_advanced_merging>>.
====

After you exit the merge tool, Git asks you if the merge was successful.
If you tell the script that it was, it stages the file to mark it as resolved for you.
You can run `git status` again to verify that all conflicts have been resolved:

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

If you're happy with that, and you verify that everything that had conflicts has been staged, you can type `git commit` to finalize the merge commit.
The commit message by default looks something like this:

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
----

If you think it would be helpful to others looking at this merge in the future, you can modify this commit message with details about how you resolved the merge and explain why you did the changes you made if these are not obvious.
