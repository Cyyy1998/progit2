[[_remote_branches]]
=== Remote na mga Branch

(((mga branch, remote)))(((mga reperensiya, remote)))
Ang remote na mga reperensiya ay mga reperensiya (mga pointer) sa iyong remote na mga repositoryo, na nagsasama ng mga branch, mga tag, at iba pa. Maaari kang tahasang makakuha ng isang buong listahan ng remote na mga reperensya gamit ang `git ls-remote [remote]`, o `git remote show [remote]` para sa remote na mga branch at marami pang impormasyon. Gayunpaman, isang mas karaniwang paraan ay ang pagsasamantala sa remote-tracking na mga branch.

Ang remote-tracking na mga branch ay mga reperensya sa estado ng remote na mga branch. Sila ay lokal na mga reperensya na hindi mo magagalaw; ginagalaw ng Git ang mga ito para sa iyo sa tuwing ikaw ay gumawa ng anumang network na komunikasyon, upang siguraduhing sila ay tama nagrerepresenta ng estado ng remote na repositoryo. Isipin sila bilang mga bookmark, upang paalalahanan ka kung saan ang mga branch sa iyong remote na mga repositoryo noong huling panahon na ikaw ay nakakonekta sa kanila.

Ang remote-tracking na mga branch ay nag-aanyong `<remote>/<branch>`. Halimbawa, kung gusto mong tingnan kung ano ang hitsura ng `master` na branch sa iyong `origin` na remote noong huling panahon na ikaw ay nakipag-usap nito, susuriin mo ang `origin/master` na branch. Kung ikaw ay nagtatrabaho sa isang isyu kasama ang isang kasosyo at sila ay nag-push paitaas ng isang `iss53` na branch, maaaring mayroon kang sariling lokal na `iss53` na branch, ngunit ang branch sa server ay marerepresenta ng remote-tracking na branch na `origin/iss53`.

Maaaring ito ay medyo nakakalito, kaya tumingin tayo sa isang halimbawa. Sabihin nating mayroon kang isang Git na server sa iyong network sa `git.ourcompany.com`. Kung ikaw ay magku-clone mula nito, ang `clone` na utos ng Git ay awtomatikong papangalanan itong `origin` para sa iyo, ipu-pull nito pababa ang lahat ng datos nito, gagawa ng isang pointer patungo kung saan ang `master` na branch nito, at lokal itong papangalanang `origin/master`. Ang Git ay nagbibigay din sa iyo ng iyong sariling lokal na `master` na branch sa pagsisimula sa parehong lugar bilang `master` na branch ng origin, kaya mayroon kang bagay na tatrabahuan.

[TANDAAN]
.Ang ``origin'' ay hindi espesyal
====
Kutulad ng pangalan ng branch na ``master'' ay walang espesyal na kahulugan sa Git, pati na ring ang ``origin''. Habang ang ``master'' ay ang default na pangalan para sa isang panimulang branch kapag ikaw ay nagpatakbo ng `git init` na ang natatanging dahilan kaya ito ay malawakang ginagamit, ang ``origin'' ay ang default na pangalan para sa isang remote kapag ikaw ay nagpatakbo ng `git clone`. Kung sa halip ikaw ay nagpatakbo ng `git clone -o booyah`, ikaw ay magkakaroon ng `booyah/master` bilang iyong default na remote na branch.(((origin)))
====

.Ang server at lokal na mga repositoryo pagkatapos ng pag-clone
image::images/remote-branches-1.png[Ang server at lokal na mga repositoryo pagkatapos ng pag-clone.]

Kung ikaw ay gumawa ng ilang trabaho sa iyong lokal na `master` na branch, at, sa pansamantala, may ibang nagpu-push sa `git.ourcompany.com` at nag-update ng `master` na branch nito, ang iyong mga kasaysayan ay kakaibang ililipat nang pasulong. Gayundin, hangga't mananatili kang umiwas sa pakikipag-usap sa iyong origin na server, ang iyong `origin/master` na pointer ay hindi gagalaw.

.Ang lokal at remote na trabaho ay maaaring ihiwalay
image::images/remote-branches-2.png[Ang lokal at remote na trabaho ay maaaring ihiwalay.]

Upang mapagsabay-sabay ang iyong trabaho, magpapatakbo ka ng isang `git fetch origin` na utos. Ang utos na ito ay titingnan kung anong server ang ``origin'' (sa kasong ito, ito ay `git.ourcompany.com`), ipi-fetch ang anumang datos mula dito na hindi pa nasa iyo, at ia-update ang iyong lokal na database, ililipat ang iyong `origin/master` na pointer sa bago, mas napapanahon nitong posisyon.

.Ang `git fetch` ay ia-update ang iyong remote na mga reperensya
image::images/remote-branches-3.png[Ang `git fetch` ay ia-update ang iyong remote na mga reperensya.]

Upang ipakita ang pagkakaroon ng maramihang remote na mga server at kung ano ang hitsura ng remote na mga branch para sa mga remote na proyekto, ating ipalagay na mayroon kang ibang panloob na Git na server na ginagamit lamang para sa pag-develop ng isa sa iyong mga sprint na mga koponan. Ang server na ito ay nasa `git.team1.ourcompany.com`. Maaari mong idagdag ito bilang isang panibagong remote na reperensya kung saan mo kasalukuyang tinatrabaho ang `git remote add` na utos na ating nasakop sa <<_git_basics_chapter#_git_basics_chapter>>. Pangalanan itong remote na `teamone`, na magiging iyong maikling pangalan para sa buong URL na iyon.

.Pagdagdag ng ibang server bilang isang remote
image::images/remote-branches-4.png[Pagdagdag ng ibang server bilang isang remote.]

Ngayon, maaari mong patakbuhin ang `git fetch teamone` upang i-fetch ang lahat ng nasa remote na `teamone` na hindi pa nasa iyo. Dahil ang server na iyon ay may isang subset ng datos na nasa iyong `origin` na server na ngayon, walang datos na ipi-fetch ang Git ngunit magtatakda ng isang remote-tracking na branch na tinatawag na `teamone/master` upang tumuro sa commit na mayroon sa `teamone` bilang `master` na branch nito.

.Ang remote tracking na branch para sa `teamone/master`
image::images/remote-branches-5.png[Ang remote tracking na branch para sa `teamone/master`.]

[[_pushing_branches]]
==== Pag-push

(((pag-push)))
Kapag gusto mong magbahagi ng isang branch sa mundo, kailangan mong i-push ito pataas sa isang remote na mayroon kang access sa pagsulat. Ang iyong lokal na mga branch ay hindi awtomatikong magkasabay-sabay sa mga remote na susulatan mo -- kailangang mong tahasang i-push ang mga branch na gusto mong ibahagi. Sa paraang iyon, maaari kang gumamit ng pribadong mga branch para sa trabahong hindi mo gustong ibahagi, at i-push pataas ang mga paksa na mga branch lamang na gusto mong makipagtulungan.

Kung mayroon kang isang branch na nakapangalang `serverfix` na gusto mong trabahuin kasama ang iba, maaari mong i-push ito pataas sa parehong paraan na na-push mo ang iyong unang branch. Patakbuhin ang `git push <remote> <branch>`:(((git na mga utos, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

Ito ay medyo parang isang daang tuwiran. Ang Git ay awtomatikong pinapalaki ang `serverfix` na pangalan ng branch palabas sa `refs/heads/serverfix:refs/heads/serverfix`, na nangangahulugang, ``Kunin mo ang aking serverfix na lokal na branch at i-push ito upang i-update ang serverfix na branch ng remote.'' Dumako tayo sa `refs/heads/` na bahagi sa detalye sa <<_git_internals#_git_internals>>, ngunit kadalasan ay maaari mo itong hayaan. Maaari ka ring gumawa ng `git push origin serverfix:serverfix`, na gumagawa ng parehong bagay -- nagsasabi ito na, ``Kunin mo ang aking serverfix at gawin itong serverfix ng remote.'' Maaari mong gamitin ang format na ito upang mag-push ng isang lokal na branch sa isang remote na branch na kakaibang nakapangalan. Kung hindi mo gustong tawagin itong `serverfix` sa remote, sa halip ay maaari mong patakbuhin ang `git push origin serverfix:awesomebranch` upang i-push ang iyong lokal na `serverfix` na branch patungo sa `awesomebranch` na branch sa remote na proyekto.

[TANDAAN]
.Huwag i-type ang iyong password sa bawat panahon
====
Kung ikaw ay gumagamit ng isang HTTPS na URL upang mag-push paitaas, ang Git na server ay hihingian ka para sa iyong username at password para sa pagpapatunay. Bilang default ito ay mag-uudyok sayo sa terminal para sa impormasyong ito upang mapagpasyahan ng server kung ikaw ay pinapahintulutang mag-push.

Kung hindi mo gustong i-type ito sa bawat isang pagkakataon na magpu-push ka, maaari mong magtakda ng isang ``credential cache''. Ang pinakasimple ay ang panatilihin ito sa memorya sa isang maikling minuto, kung saan maaari mong madaling itakda sa pamamagitan ng pagpapatakbo ng `git config --global credential.helper cache`.

Para sa karagdagang impormasyon sa iba't ibang mga opsyon ng credential caching na maaaring magamit, tingnan ang <<_git_tools#_credential_caching>>.
====

Sa susunod na panahon na isa sa iyong mga katulong ay mag-fetch mula sa server, sila ay makakatanggap ng isang reperensya kung saan ang bersyon ng server ng `serverfix` sa ilalim ng remote na branch na `origin/serverfix`:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

It's important to note that when you do a fetch that brings down new remote-tracking branches, you don't automatically have local, editable copies of them.
In other words, in this case, you don't have a new `serverfix` branch -- you only have an `origin/serverfix` pointer that you can't modify.

To merge this work into your current working branch, you can run `git merge origin/serverfix`.
If you want your own `serverfix` branch that you can work on, you can base it off your remote-tracking branch:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

This gives you a local branch that you can work on that starts where `origin/serverfix` is.

[[_tracking_branches]]
==== Tracking Branches

(((branches, tracking)))(((branches, upstream)))
Checking out a local branch from a remote-tracking branch automatically creates what is called a ``tracking branch'' (and the branch it tracks is called an ``upstream branch'').
Tracking branches are local branches that have a direct relationship to a remote branch.
If you're on a tracking branch and type `git pull`, Git automatically knows which server to fetch from and branch to merge into.

When you clone a repository, it generally automatically creates a `master` branch that tracks `origin/master`.
However, you can set up other tracking branches if you wish -- ones that track branches on other remotes, or don't track the `master` branch.
The simple case is the example you just saw, running `git checkout -b <branch> <remote>/<branch>`.
This is a common enough operation that Git provides the `--track` shorthand:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

In fact, this is so common that there's even a shortcut for that shortcut. If the branch name you're trying to checkout (a) doesn't exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you:

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Now, your local branch `sf` will automatically pull from `origin/serverfix`.

If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you're tracking, you can use the `-u` or `--set-upstream-to` option to `git branch` to explicitly set it at any time.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Upstream shorthand
====
When you have a tracking branch set up, you can reference its upstream branch with the `@{upstream}` or `@{u}` shorthand.
So if you're on the `master` branch and it's tracking `origin/master`, you can say something like `git merge @{u}` instead of `git merge origin/master` if you wish.(((+++@{u}+++)))(((+++@{upstream}+++)))
====

If you want to see what tracking branches you have set up, you can use the `-vv` option to `git branch`.
This will list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

So here we can see that our `iss53` branch is tracking `origin/iss53` and is ``ahead'' by two, meaning that we have two commits locally that are not pushed to the server.
We can also see that our `master` branch is tracking `origin/master` and is up to date.
Next we can see that our `serverfix` branch is tracking the `server-fix-good` branch on our `teamone` server and is ahead by three and behind by one, meaning that there is one commit on the server we haven't merged in yet and three commits locally that we haven't pushed.
Finally we can see that our `testing` branch is not tracking any remote branch.

It's important to note that these numbers are only since the last time you fetched from each server.
This command does not reach out to the servers, it's telling you about what it has cached from these servers locally.
If you want totally up to date ahead and behind numbers, you'll need to fetch from all your remotes right before running this.
You could do that like this:

[source,console]
----
$ git fetch --all; git branch -vv
----

==== Pulling

(((pulling)))
While the `git fetch` command will fetch down all the changes on the server that you don't have yet, it will not modify your working directory at all.
It will simply get the data for you and let you merge it yourself.
However, there is a command called `git pull` which is essentially a `git fetch` immediately followed by a `git merge` in most cases.
If you have a tracking branch set up as demonstrated in the last section, either by explicitly setting it or by having it created for you by the `clone` or `checkout` commands, `git pull` will look up what server and branch your current branch is tracking, fetch from that server and then try to merge in that remote branch.

Generally it's better to simply use the `fetch` and `merge` commands explicitly as the magic of `git pull` can often be confusing.

[[_delete_branches]]
==== Deleting Remote Branches

(((branches, deleting remote)))
Suppose you're done with a remote branch – say you and your collaborators are finished with a feature and have merged it into your remote's `master` branch (or whatever branch your stable codeline is in).
You can delete a remote branch using the `--delete` option to `git push`.
If you want to delete your `serverfix` branch from the server, you run the following:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

Basically all this does is remove the pointer from the server.
The Git server will generally keep the data there for a while until a garbage collection runs, so if it was accidentally deleted, it's often easy to recover.
