=== Mga Daloy ng Trabaho sa Pag-branch 

Ngayon na mayroon ka nang mga batayan sa pag-branch at pag-merge down, ano ang maaari o dapat mong gawin sa mga ito? Sa seksyong ito, sasakupin natin ang ilang karaniwang mga daloy ng trabaho na ginagawang posible ang magaan na pag-branch, upang ikaw ay makapagpasya kung gusto mong isama ito sa iyong sariling development cycle.

==== Matagal na Tumatakbong mga Branch

(((mga branch, matagal na tumatakbo)))
Dahil ang Git ay gumagamit ng isang simpleng three-way na merge, ang pag-merge mula sa isang branch patungo sa iba pa nang maraming beses sa isang mahabang panahon ay kadalasang madaling gawin. Ang ibig sabihin nito ay maaari kang magkaroon ng iilang mga branch na palaging nakabukas at magagamit mo sa iba't ibang mga yugto ng iyong development cycle; maaari kang regular na mag-merge mula sa ilan sa kanila patungo sa mga iba pa.

Karamihan sa mga developer ng Git ay maroong isang daloy ng trabaho na tumatanggap ng ganitong paraan, katulad ng pagkakaroon ng code na buong matatag sa kanilang `master` na branch -- posibleng code lamang na na-release o iri-release. Mayroon silang ibang kahilera na branch na nakapangalang `develop` o `next` na tinatrabaho nila o ginagamit upang i-test ang katatagan -- ito ay hindi kinakailangang palaging matatag, ngunit tuwing ito ay makakakuha ng isang matatag na estado, maaari itong i-merge sa `master`. Ginagamit ito upang maka-pull sa paksa na mga branch (maikling buhay na mga branch, katulad ng `iss53` na branch kamakailan lamang) kapag handa na ang mga ito, upang siguraduhing sila ay pasado sa lahat ng mga pagsubok at hindi magpapakilala ng mga bug.

In reality, we're talking about pointers moving up the line of commits you're making.
The stable branches are farther down the line in your commit history, and the bleeding-edge branches are farther up the history.

.A linear view of progressive-stability branching
image::images/lr-branches-1.png[A linear view of progressive-stability branching.]

It's generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when they're fully tested.

[[lrbranch_b]]
.A ``silo'' view of progressive-stability branching
image::images/lr-branches-2.png[A ``silo'' view of progressive-stability branching.]

You can keep doing this for several levels of stability.
Some larger projects also have a `proposed` or `pu` (proposed updates) branch that has integrated branches that may not be ready to go into the `next` or `master` branch.
The idea is that your branches are at various levels of stability; when they reach a more stable level, they're merged into the branch above them.
Again, having multiple long-running branches isn't necessary, but it's often helpful, especially when you're dealing with very large or complex projects.

[[_topic_branch]]
==== Topic Branches

(((branches, topic)))
Topic branches, however, are useful in projects of any size.
A topic branch is a short-lived branch that you create and use for a single particular feature or related work.
This is something you've likely never done with a VCS before because it's generally too expensive to create and merge branches.
But in Git it's common to create, work on, merge, and delete branches several times a day.

You saw this in the last section with the `iss53` and `hotfix` branches you created.
You did a few commits on them and deleted them directly after merging them into your main branch.
This technique allows you to context-switch quickly and completely -- because your work is separated into silos where all the changes in that branch have to do with that topic, it's easier to see what has happened during code review and such.
You can keep the changes there for minutes, days, or months, and merge them in when they're ready, regardless of the order in which they were created or worked on.

Consider an example of doing some work (on `master`), branching off for an issue (`iss91`), working on it for a bit, branching off the second branch to try another way of handling the same thing (`iss91v2`), going back to your `master` branch and working there for a while, and then branching off there to do some work that you're not sure is a good idea (`dumbidea` branch).
Your commit history will look something like this:

.Multiple topic branches
image::images/topic-branches-1.png[Multiple topic branches.]

Now, let's say you decide you like the second solution to your issue best (`iss91v2`); and you showed the `dumbidea` branch to your coworkers, and it turns out to be genius.
You can throw away the original `iss91` branch (losing commits `C5` and `C6`) and merge in the other two.
Your history then looks like this:

.History after merging `dumbidea` and `iss91v2`
image::images/topic-branches-2.png[History after merging `dumbidea` and `iss91v2`.]

We will go into more detail about the various possible workflows for your Git project in <<_distributed_git#_distributed_git>>, so before you decide which branching scheme your next project will use, be sure to read that chapter.

It's important to remember when you're doing all this that these branches are completely local.
When you're branching and merging, everything is being done only in your Git repository -- no server communication is happening.
