=== JGit

(((jgit)))(((java)))
Kung nais mong gamitin ang Git mula sa loob ng isang programa ng Java, mayroong isang ganap na itinatampok na library ng Git na tinatawag na JGit.
Ang JGit ay isang ganap na buong-tampok na pagsasagawa ng Git na nakasulat na natively sa Java, at malawakang ginagamit sa komunidad ng Java.
Ang prouektong JGit ay nasa ilalim ng Eclipse umbrella, at ang pinanggalingan nito ay matatagpuan sa http://www.eclipse.org/jgit[].

==== Pagkuha ng Set Up

Mayroong ilang mga paraan upang ikonekta ang iyong proyekto sa JGit at simulan ang pagsulat ng code laban dito.
Marahil ang pinakamadali ay ang paggamit ng Maven - ang pagsasama ay gagawin sa pamamagitan ng pagdaragdag ng sumusunod na snippet sa `<dependencies>` na tag sa iyong pom.xml na file:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

Ang `bersyon` ay malamang na may advance sa oras na nabasa mo ito; suriin http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] para sa na-update na impormasyon ng imbakan.
Kapag ang hakbang na ito ay tapos na, Maven ay awtomatikong makuha at gamitin ang mga JGit library na kakailanganin mo.

Kung masgugustuhin mong pamahalaan ang mga binary dependencies sa iyong sarili, ang mga pre-built JGit binary ay makukuha mula sa http://www.eclipse.org/jgit/download[].
Maaari kang bumuo ng mga ito sa iyong proyekto sa pamamagitan ng pagpapatakbo ng isang command tulad nito:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Plumbing

Ang JGit ay may dalawang pangunahing antas ng API: plumbing at porcelain.
Ang terminolohiya ng mga ito ay nagmula sa Git mismo, at ang JGit ay nahahati sa halos parehong mga uri ng mga lugar: ang mga porcelain API ay isang friendly na front-end para sa karaniwang mga pagkilos sa antas ng user (ang mga uri ng mga bagay na ginagamit ng isang normal na user na tool para sa command-line na Git), habang ang mga plumbing API ay direktang nakikipag-ugnay sa mga mababang antas ng mga bagay sa imbakan.

Ang panimulang punto para sa karamihan ng mga sesyon ng JGit ay ang `Repository` na class, at ang unang bagay na gusto mong gawin ay lumikha ng isang halimbawa nito. Para sa filesystem-based na imbakan (oo, pinapayagan ng JGit para sa iba pang mga modelo ng imbakan), ito ay gagawin gamit ang `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

Ang tagagawa ay may matatas na API para sa pagbibigay ng lahat ng mga bagay na kailangan nito upang makahanap ng isang Git repository, kahit alam man o hindi ang iyong programa kung saan mismo matatagpuan ito. Maaari itong gumamit ng mga environment variable (`.readEnvironment ()`), magsimula sa isang lugar sa gumagana na direktoryo at paghahanap (`.setWorkTree (...).findGitDir ()`), o buksan lamang ang isang nakatalang direktoryo ng `.git` .


Sa sandaling mayroon kang isang halimbawa na `Repository, maaari mong gawin ang lahat ng mga uri ng mga bagay dito.
Narito ang isang mabilis na sampling:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

Mayroong medyo kaunting ginawa dito, kaya't hayaan natin ito nang isang seksyon sa isang pagkakataon.

Ang unang linya ay nakakakuha ng isang pointer sa `master` reference. Ang JGit ay awtomatikong kunin ang _actual_ master ref, na nasa `refs/head/master`, at nagbalik ng isang bagay na nagbibigay-daan sa iyo makuha ang impormasyon tungkol sa reference. Maaari mong makakuha ang pangalan (`.getName()`), at alinman sa target na bagay ng direktang reference (`.getObjectId()`) o ang reference na itinuturo ng isang symbolic ref (`.getTarget()`). Ang mga ref na bagay ay ginagamit din upang kumatawan sa mga ref ng mga tag at mga bagay, upang maaari mong tanungin kung ang tag ay "peeled," na nangangahulugan na tumuturo ito sa huling target ng isang (potensyal na mahaba) na string ng mga bagay ng tag.

Ang ikalawang linya ay nakakakuha ng target ng `master` reference, na ibinalik bilang isang ObjectId instance.
Ang ObjectId ay kumakatawan sa SHA-1 hash ng bagay, na maaaring o hindi maaaring umiiral sa database ng Git's na bagay.
Ang ikatlong linya ay pareho, ngunit nagpapakita kung paano pinangangasiwaan ng JGit ang rev-parse na syntax (para sa higit pa nito, tingnan ang <<_git_tools#_branch_references>>); maaari mong ipasa ang anumang specifier ng bagay na nauunawaan ng Git, at ibabalik ng JGit alinman sa isang balidong ObjectId para sa bagay na iyon, o `null`.

Ang susunod na dalawang linya ay nagpapakita kung paano i-load ang mga raw na nilalaman ng isang bagay.
Sa halimbawang ito, tinatawagan namin ang `ObjectLoader.copyTo()` upang i-stream ang mga nilalaman ng bagay direkta sa stdout, ngunit ang ObjectLoader ay mayroon ding mga paraan upang mabasa ang uri at laki ng isang bagay, pati na rin ibalik ito bilang isang byte array.
Para sa mga malalaking bagay (kung saan ang `.isLarge()` ay nagbabalik ng `true`), maaari kang tumawag sa `.openStream()` upang makakuha ng InputStream-like na bagay na makakapagbasa ng raw na datos na bagay nang hindi naibabalik ang lahat ng ito sa memorya nang sabay-sabay.

The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call `.update()` to trigger the change.
Directly following this is the code to delete that same branch.
Note that `.setForceUpdate(true)` is required for this to work; otherwise the `.delete()` call will return `REJECTED`, and nothing will happen.

The last example shows how to fetch the `user.name` value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration, but will automatically detect the global and system configuration files and read values from them as well.

This is only a small sampling of the full plumbing API; there are many more methods and classes available.
Also not shown here is the way JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as `IOException`), but there are a host of JGit-specific exception types that are provided as well (such as `NoRemoteRepositoryException`, `CorruptObjectException`, and `NoMergeBaseException`).

==== Porcelain

The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common goals, like adding a file to the index, or making a new commit.
JGit provides a higher-level set of APIs to help out with this, and the entry point to these APIs is the `Git` class:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

The Git class has a nice set of high-level _builder_-style methods that can be used to construct some pretty complex behavior.
Let's take a look at an example â€“ doing something like `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

This is a common pattern with the Git class; the methods return a command object that lets you chain method calls to set parameters, which are executed when you call `.call()`.
In this case, we're asking the `origin` remote for tags, but not heads.
Also notice the use of a `CredentialsProvider` object for authentication.

Many other commands are available through the Git class, including but not limited to `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, and `reset`.

==== Further Reading

This is only a small sampling of JGit's full capabilities.
If you're interested and want to learn more, here's where to look for information and inspiration:

* The official JGit API documentation can be found at http://www.eclipse.org/jgit/documentation/[].
  These are standard Javadoc, so your favorite JVM IDE will be able to install them locally, as well.
* The JGit Cookbook at https://github.com/centic9/jgit-cookbook[] has many examples of how to do specific tasks with JGit.
* There are several good resources pointed out at http://stackoverflow.com/questions/6861881[].
