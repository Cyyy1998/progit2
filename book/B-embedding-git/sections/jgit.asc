=== JGit

(((jgit)))(((java)))
Kung nais mong gamitin ang Git mula sa loob ng isang programa ng Java, mayroong isang ganap na itinatampok na library ng Git na tinatawag na JGit.
Ang JGit ay isang ganap na buong-tampok na pagsasagawa ng Git na nakasulat na natively sa Java, at malawakang ginagamit sa komunidad ng Java.
Ang prouektong JGit ay nasa ilalim ng Eclipse umbrella, at ang pinanggalingan nito ay matatagpuan sa http://www.eclipse.org/jgit[].

==== Pagkuha ng Set Up

Mayroong ilang mga paraan upang ikonekta ang iyong proyekto sa JGit at simulan ang pagsulat ng code laban dito.
Marahil ang pinakamadali ay ang paggamit ng Maven - ang pagsasama ay gagawin sa pamamagitan ng pagdaragdag ng sumusunod na snippet sa `<dependencies>` na tag sa iyong pom.xml na file:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

Ang `bersyon` ay malamang na may advance sa oras na nabasa mo ito; suriin http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] para sa na-update na impormasyon ng imbakan.
Kapag ang hakbang na ito ay tapos na, Maven ay awtomatikong makuha at gamitin ang mga JGit library na kakailanganin mo.

Kung masgugustuhin mong pamahalaan ang mga binary dependencies sa iyong sarili, ang mga pre-built JGit binary ay makukuha mula sa http://www.eclipse.org/jgit/download[].
Maaari kang bumuo ng mga ito sa iyong proyekto sa pamamagitan ng pagpapatakbo ng isang command tulad nito:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Plumbing

Ang JGit ay may dalawang pangunahing antas ng API: plumbing at porcelain.
Ang terminolohiya ng mga ito ay nagmula sa Git mismo, at ang JGit ay nahahati sa halos parehong mga uri ng mga lugar: ang mga porcelain API ay isang friendly na front-end para sa karaniwang mga pagkilos sa antas ng user (ang mga uri ng mga bagay na ginagamit ng isang normal na user na tool para sa command-line na Git), habang ang mga plumbing API ay direktang nakikipag-ugnay sa mga mababang antas ng mga bagay sa imbakan.

Ang panimulang punto para sa karamihan ng mga sesyon ng JGit ay ang `Repository` na class, at ang unang bagay na gusto mong gawin ay lumikha ng isang halimbawa nito. Para sa filesystem-based na imbakan (oo, pinapayagan ng JGit para sa iba pang mga modelo ng imbakan), ito ay gagawin gamit ang `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

The builder has a fluent API for providing all the things it needs to find a Git repository, whether or not your program knows exactly where it's located.
It can use environment variables (`.readEnvironment()`), start from a place in the working directory and search (`.setWorkTree(…).findGitDir()`), or just open a known `.git` directory as above.

Once you have a `Repository` instance, you can do all sorts of things with it.
Here's a quick sampling:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

There's quite a bit going on here, so let's go through it one section at a time.

The first line gets a pointer to the `master` reference.
JGit automatically grabs the _actual_ master ref, which lives at `refs/heads/master`, and returns an object that lets you fetch information about the reference.
You can get the name (`.getName()`), and either the target object of a direct reference (`.getObjectId()`) or the reference pointed to by a symbolic ref (`.getTarget()`).
Ref objects are also used to represent tag refs and objects, so you can ask if the tag is ``peeled,'' meaning that it points to the final target of a (potentially long) string of tag objects.

The second line gets the target of the `master` reference, which is returned as an ObjectId instance.
ObjectId represents the SHA-1 hash of an object, which might or might not exist in Git's object database.
The third line is similar, but shows how JGit handles the rev-parse syntax (for more on this, see <<_git_tools#_branch_references>>); you can pass any object specifier that Git understands, and JGit will return either a valid ObjectId for that object, or `null`.

The next two lines show how to load the raw contents of an object.
In this example, we call `ObjectLoader.copyTo()` to stream the contents of the object directly to stdout, but ObjectLoader also has methods to read the type and size of an object, as well as return it as a byte array.
For large objects (where `.isLarge()` returns `true`), you can call `.openStream()` to get an InputStream-like object that can read the raw object data without pulling it all into memory at once.

The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call `.update()` to trigger the change.
Directly following this is the code to delete that same branch.
Note that `.setForceUpdate(true)` is required for this to work; otherwise the `.delete()` call will return `REJECTED`, and nothing will happen.

The last example shows how to fetch the `user.name` value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration, but will automatically detect the global and system configuration files and read values from them as well.

This is only a small sampling of the full plumbing API; there are many more methods and classes available.
Also not shown here is the way JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as `IOException`), but there are a host of JGit-specific exception types that are provided as well (such as `NoRemoteRepositoryException`, `CorruptObjectException`, and `NoMergeBaseException`).

==== Porcelain

The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common goals, like adding a file to the index, or making a new commit.
JGit provides a higher-level set of APIs to help out with this, and the entry point to these APIs is the `Git` class:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

The Git class has a nice set of high-level _builder_-style methods that can be used to construct some pretty complex behavior.
Let's take a look at an example – doing something like `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

This is a common pattern with the Git class; the methods return a command object that lets you chain method calls to set parameters, which are executed when you call `.call()`.
In this case, we're asking the `origin` remote for tags, but not heads.
Also notice the use of a `CredentialsProvider` object for authentication.

Many other commands are available through the Git class, including but not limited to `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, and `reset`.

==== Further Reading

This is only a small sampling of JGit's full capabilities.
If you're interested and want to learn more, here's where to look for information and inspiration:

* The official JGit API documentation can be found at http://www.eclipse.org/jgit/documentation/[].
  These are standard Javadoc, so your favorite JVM IDE will be able to install them locally, as well.
* The JGit Cookbook at https://github.com/centic9/jgit-cookbook[] has many examples of how to do specific tasks with JGit.
* There are several good resources pointed out at http://stackoverflow.com/questions/6861881[].
